# action_tutorial_py

## Overview
This package demonstrates ROS2 actions in Python using `rclpy.action`. Actions provide a way to execute long-running tasks with feedback and cancellation support.

## Purpose
Learn ROS2 action patterns in Python:
- Creating action servers
- Creating action clients
- Handling goal requests, cancellation, and execution
- Publishing feedback during execution
- Returning results upon completion

## Prerequisites
- ROS2 Jazzy installed and sourced
- `colcon` build tools
- Python 3.8 or higher
- The `custom_action` package must be built first (for action definition)

## Important: Build Order

**⚠️ You must build the `custom_action` package first** before building this package, as this package depends on the action interfaces generated by that package.

```bash
# Build the interface package first
colcon build --packages-select custom_action

# Then build this package
colcon build --packages-select action_tutorial_py --symlink-install

# Source the workspace
source install/setup.bash
```

## Building
```bash
cd ~/ros2_ws/src
# Ensure custom_action is built first
colcon build --packages-select custom_action
# Then build this package
colcon build --packages-select action_tutorial_py --symlink-install
source install/setup.bash
```

## Usage

### Simple Action Server
```bash
ros2 run action_tutorial_py simple_action_server
```

### Simple Action Client
```bash
ros2 run action_tutorial_py simple_action_client
```

### Class-based Action Server
```bash
ros2 run action_tutorial_py class_action_server
```

### Class-based Action Client
```bash
ros2 run action_tutorial_py class_action_client
```

### Sending Goals from Command Line
```bash
ros2 action send_goal /concatenation \
  custom_action/action/Concatenate "{num_concatenations: 5}"
```

## Key Concepts
- **Action Server**: `ActionServer(node, ActionType, action_name, execute_callback, ...)`
- **Action Client**: `ActionClient(node, ActionType, action_name)`
- **Goal Handling**: `goal_callback` to accept/reject goals (returns `GoalResponse.ACCEPT` or `GoalResponse.REJECT`)
- **Cancel Handling**: `cancel_callback` for cancellation requests (returns `CancelResponse.ACCEPT` or `CancelResponse.REJECT`)
- **Execution**: `execute_callback` runs the action logic and returns the result object
- **Feedback**: `goal_handle.publish_feedback(feedback_msg)` to send progress updates
- **Result**: `goal_handle.succeed()` or `goal_handle.canceled()` (called without arguments), then return result from execute callback

## Jazzy-Specific API Notes

### Action Server (Jazzy API)
- `goal_handle.succeed()` and `goal_handle.canceled()` are called **without** the result parameter
- The execute callback must **return** the result object:
  ```python
  def execute_callback(self, goal_handle):
      result = Concatenate.Result()
      result.final_concatenation = concatenation
      goal_handle.succeed()  # No result parameter
      return result  # Return result from callback
  ```

### Action Client (Jazzy API)
- Import `GoalStatus` from `action_msgs.msg` (not `rclpy.action`):
  ```python
  from action_msgs.msg import GoalStatus
  if wrapped_result.status == GoalStatus.STATUS_SUCCEEDED:
      # Handle success
  ```
- Feedback callback receives a `FeedbackMessage` object - access feedback via `feedback.feedback.field_name`:
  ```python
  def feedback_callback(self, feedback):
      self.get_logger().info(f'Feedback: {feedback.feedback.partial_concatenation}')
  ```

## Action Definition
Uses `Concatenate` action from `custom_action` package:
- **Goal**: `num_concatenations` (int16) - Number of concatenations to perform
- **Result**: `final_concatenation` (string) - Final concatenated string
- **Feedback**: `partial_concatenation` (string) - Progress update

## Why Use C++ Interface Package?

In ROS 2, custom actions (like messages and services) should be defined in `ament_cmake` (C++) packages. This package demonstrates how Python nodes can use interfaces defined in C++ packages. The `custom_action` package defines the interface, and this package uses it.

## Files
- `simple_action_server.py` - Functional action server
- `simple_action_client.py` - Functional action client
- `class_action_server.py` - Class-based action server
- `class_action_client.py` - Class-based action client

